using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;

namespace MauiBootstrapTheme.Build.Tasks;

/// <summary>
/// MSBuild task that generates Bootstrap theme code from CSS files.
/// </summary>
public class GenerateBootstrapThemeTask : Task
{
    /// <summary>
    /// The Bootstrap CSS file to parse.
    /// </summary>
    [Required]
    public string? CssFile { get; set; }

    /// <summary>
    /// The output directory for generated code.
    /// </summary>
    [Required]
    public string? OutputDirectory { get; set; }

    /// <summary>
    /// The namespace for generated code.
    /// </summary>
    public string Namespace { get; set; } = "MauiBootstrapTheme.Generated";

    public override bool Execute()
    {
        try
        {
            if (string.IsNullOrEmpty(CssFile) || !File.Exists(CssFile))
            {
                Log.LogError($"CSS file not found: {CssFile}");
                return false;
            }

            if (string.IsNullOrEmpty(OutputDirectory))
            {
                Log.LogError("OutputDirectory is required.");
                return false;
            }

            Directory.CreateDirectory(OutputDirectory);

            Log.LogMessage(MessageImportance.Normal, $"Parsing Bootstrap CSS: {CssFile}");
            
            var cssContent = File.ReadAllText(CssFile);
            var variables = ParseCssVariables(cssContent);

            Log.LogMessage(MessageImportance.Normal, $"Found {variables.Count} CSS variables");

            var generatedCode = GenerateThemeCode(variables);
            var outputPath = Path.Combine(OutputDirectory, "BootstrapTheme.g.cs");
            File.WriteAllText(outputPath, generatedCode);

            Log.LogMessage(MessageImportance.Normal, $"Generated: {outputPath}");

            return true;
        }
        catch (Exception ex)
        {
            Log.LogErrorFromException(ex, showStackTrace: true);
            return false;
        }
    }

    private Dictionary<string, string> ParseCssVariables(string css)
    {
        var variables = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        
        // Parse CSS custom properties (--bs-*)
        var pattern = @"--bs-([a-zA-Z0-9-]+)\s*:\s*([^;]+);";
        var matches = System.Text.RegularExpressions.Regex.Matches(css, pattern);
        
        foreach (System.Text.RegularExpressions.Match match in matches)
        {
            var name = $"--bs-{match.Groups[1].Value}";
            var value = match.Groups[2].Value.Trim();
            variables[name] = value;
        }
        
        return variables;
    }

    private string GenerateThemeCode(Dictionary<string, string> variables)
    {
        var sb = new System.Text.StringBuilder();
        
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This file was generated by MauiBootstrapTheme.Build. Do not edit manually.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine($"namespace {Namespace};");
        sb.AppendLine();
        sb.AppendLine("public static partial class BootstrapColors");
        sb.AppendLine("{");

        // Generate color constants
        var colorMappings = new Dictionary<string, string>
        {
            { "--bs-primary", "Primary" },
            { "--bs-secondary", "Secondary" },
            { "--bs-success", "Success" },
            { "--bs-danger", "Danger" },
            { "--bs-warning", "Warning" },
            { "--bs-info", "Info" },
            { "--bs-light", "Light" },
            { "--bs-dark", "Dark" },
            { "--bs-body-bg", "Background" },
            { "--bs-body-color", "OnBackground" },
            { "--bs-border-color", "Outline" },
        };

        foreach (var mapping in colorMappings)
        {
            if (variables.TryGetValue(mapping.Key, out var value))
            {
                var colorValue = ParseColor(value);
                sb.AppendLine($"    public static readonly Microsoft.Maui.Graphics.Color {mapping.Value} = Microsoft.Maui.Graphics.Color.FromArgb(\"{colorValue}\");");
            }
        }

        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("public static partial class BootstrapSizing");
        sb.AppendLine("{");

        // Generate sizing constants
        var sizingMappings = new Dictionary<string, string>
        {
            { "--bs-border-radius", "CornerRadius" },
            { "--bs-border-radius-sm", "CornerRadiusSm" },
            { "--bs-border-radius-lg", "CornerRadiusLg" },
            { "--bs-border-width", "BorderWidth" },
        };

        foreach (var mapping in sizingMappings)
        {
            if (variables.TryGetValue(mapping.Key, out var value))
            {
                var numericValue = ParseSize(value);
                sb.AppendLine($"    public const double {mapping.Value} = {numericValue};");
            }
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private string ParseColor(string value)
    {
        // Handle various color formats
        value = value.Trim();
        
        // Already a hex color
        if (value.StartsWith("#"))
        {
            return value;
        }
        
        // RGB/RGBA
        if (value.StartsWith("rgb"))
        {
            // Simplified - in production, properly parse rgb/rgba
            return "#000000";
        }
        
        // Named color - return as-is for now
        return value;
    }

    private string ParseSize(string value)
    {
        value = value.Trim();
        
        // Remove units and convert
        if (value.EndsWith("px"))
        {
            return value.Replace("px", "").Trim();
        }
        
        if (value.EndsWith("rem"))
        {
            // Assume 16px base
            if (double.TryParse(value.Replace("rem", "").Trim(), out var rem))
            {
                return (rem * 16).ToString();
            }
        }
        
        if (value.EndsWith("em"))
        {
            if (double.TryParse(value.Replace("em", "").Trim(), out var em))
            {
                return (em * 16).ToString();
            }
        }
        
        return "0";
    }
}
